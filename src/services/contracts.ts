import {
  createPublicClient,
  createWalletClient,
  http,
  custom,
  parseEther,
  formatEther,
  type Address,
  type Hash,
  type PublicClient,
  type WalletClient,
  type WriteContractParameters,
  type GetContractReturnType
} from 'viem';
import { rokoNetwork } from '../config/chains';
import { WEB3_CONFIG, GOVERNANCE_CONFIG, STAKING_CONFIG } from '../config/constants';

// Smart Contract ABIs (simplified versions - would be generated by TypeChain in production)
export const ROKO_TOKEN_ABI = [
  {
    inputs: [{ name: 'spender', type: 'address' }, { name: 'amount', type: 'uint256' }],
    name: 'approve',
    outputs: [{ name: '', type: 'bool' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ name: 'to', type: 'address' }, { name: 'amount', type: 'uint256' }],
    name: 'transfer',
    outputs: [{ name: '', type: 'bool' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [],
    name: 'totalSupply',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

export const PW_ROKO_TOKEN_ABI = [
  ...ROKO_TOKEN_ABI,
  {
    inputs: [{ name: 'delegatee', type: 'address' }],
    name: 'delegate',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'getVotingPower',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'delegates',
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

export const STAKING_ABI = [
  {
    inputs: [{ name: 'amount', type: 'uint256' }],
    name: 'stake',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'amount', type: 'uint256' }],
    name: 'unstake',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [],
    name: 'claimRewards',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'getStakedAmount',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'getPendingRewards',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'getStakingInfo',
    outputs: [
      { name: 'staked', type: 'uint256' },
      { name: 'rewards', type: 'uint256' },
      { name: 'lockEndTime', type: 'uint256' }
    ],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

export const GOVERNANCE_ABI = [
  {
    inputs: [
      { name: 'targets', type: 'address[]' },
      { name: 'values', type: 'uint256[]' },
      { name: 'calldatas', type: 'bytes[]' },
      { name: 'description', type: 'string' }
    ],
    name: 'propose',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'proposalId', type: 'uint256' }, { name: 'support', type: 'uint8' }],
    name: 'castVote',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [
      { name: 'proposalId', type: 'uint256' },
      { name: 'support', type: 'uint8' },
      { name: 'reason', type: 'string' }
    ],
    name: 'castVoteWithReason',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'proposalId', type: 'uint256' }],
    name: 'execute',
    outputs: [],
    stateMutability: 'payable',
    type: 'function',
  },
  {
    inputs: [{ name: 'proposalId', type: 'uint256' }],
    name: 'getProposal',
    outputs: [
      { name: 'id', type: 'uint256' },
      { name: 'proposer', type: 'address' },
      { name: 'startTime', type: 'uint256' },
      { name: 'endTime', type: 'uint256' },
      { name: 'forVotes', type: 'uint256' },
      { name: 'againstVotes', type: 'uint256' },
      { name: 'abstainVotes', type: 'uint256' },
      { name: 'canceled', type: 'bool' },
      { name: 'executed', type: 'bool' }
    ],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'proposalCount',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

export const REPUTATION_NFT_ABI = [
  {
    inputs: [
      { name: 'to', type: 'address' },
      { name: 'id', type: 'uint256' },
      { name: 'amount', type: 'uint256' },
      { name: 'data', type: 'bytes' }
    ],
    name: 'mint',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }, { name: 'id', type: 'uint256' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'getReputation',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

// Contract addresses
export const CONTRACTS = {
  ROKO_TOKEN: WEB3_CONFIG.contracts.ROKO_TOKEN as Address,
  PW_ROKO_TOKEN: WEB3_CONFIG.contracts.PW_ROKO_TOKEN as Address,
  GOVERNANCE: WEB3_CONFIG.contracts.GOVERNANCE as Address,
  STAKING: WEB3_CONFIG.contracts.STAKING as Address,
  REPUTATION_NFT: WEB3_CONFIG.contracts.REPUTATION_NFT as Address,
  TIMELOCK: WEB3_CONFIG.contracts.TIMELOCK as Address,
} as const;

// Create clients
export const publicClient = createPublicClient({
  chain: rokoNetwork,
  transport: http(rokoNetwork.rpcUrls.default.http[0]),
});

export const createWalletClientForProvider = (provider: any): WalletClient => {
  return createWalletClient({
    chain: rokoNetwork,
    transport: custom(provider),
  });
};

// Contract interaction helpers
export class ContractService {
  private publicClient: PublicClient;
  private walletClient?: WalletClient;

  constructor(walletClient?: WalletClient) {
    this.publicClient = publicClient;
    this.walletClient = walletClient;
  }

  // Gas estimation helper
  async estimateGas(params: any): Promise<bigint> {
    try {
      return await this.publicClient.estimateContractGas(params);
    } catch (error) {
      console.error('Gas estimation failed:', error);
      // Return a conservative estimate
      return 200000n;
    }
  }

  // Generic contract write function
  async writeContract(params: WriteContractParameters): Promise<Hash> {
    if (!this.walletClient) {
      throw new Error('Wallet client not available');
    }

    try {
      // Estimate gas first
      const gas = await this.estimateGas(params);

      return await this.walletClient.writeContract({
        ...params,
        gas: gas * 110n / 100n, // Add 10% buffer
      });
    } catch (error) {
      console.error('Contract write failed:', error);
      throw error;
    }
  }

  // ROKO Token methods
  async approveROKO(spender: Address, amount: bigint): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.ROKO_TOKEN,
      abi: ROKO_TOKEN_ABI,
      functionName: 'approve',
      args: [spender, amount],
    });
  }

  async transferROKO(to: Address, amount: bigint): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.ROKO_TOKEN,
      abi: ROKO_TOKEN_ABI,
      functionName: 'transfer',
      args: [to, amount],
    });
  }

  async getROKOBalance(account: Address): Promise<bigint> {
    return this.publicClient.readContract({
      address: CONTRACTS.ROKO_TOKEN,
      abi: ROKO_TOKEN_ABI,
      functionName: 'balanceOf',
      args: [account],
    });
  }

  // pwROKO Token methods
  async delegateVotes(delegatee: Address): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.PW_ROKO_TOKEN,
      abi: PW_ROKO_TOKEN_ABI,
      functionName: 'delegate',
      args: [delegatee],
    });
  }

  async getVotingPower(account: Address): Promise<bigint> {
    return this.publicClient.readContract({
      address: CONTRACTS.PW_ROKO_TOKEN,
      abi: PW_ROKO_TOKEN_ABI,
      functionName: 'getVotingPower',
      args: [account],
    });
  }

  async getDelegates(account: Address): Promise<Address> {
    return this.publicClient.readContract({
      address: CONTRACTS.PW_ROKO_TOKEN,
      abi: PW_ROKO_TOKEN_ABI,
      functionName: 'delegates',
      args: [account],
    });
  }

  // Staking methods
  async stake(amount: bigint): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.STAKING,
      abi: STAKING_ABI,
      functionName: 'stake',
      args: [amount],
    });
  }

  async unstake(amount: bigint): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.STAKING,
      abi: STAKING_ABI,
      functionName: 'unstake',
      args: [amount],
    });
  }

  async claimStakingRewards(): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.STAKING,
      abi: STAKING_ABI,
      functionName: 'claimRewards',
      args: [],
    });
  }

  async getStakingInfo(account: Address): Promise<{
    staked: bigint;
    rewards: bigint;
    lockEndTime: bigint;
  }> {
    const result = await this.publicClient.readContract({
      address: CONTRACTS.STAKING,
      abi: STAKING_ABI,
      functionName: 'getStakingInfo',
      args: [account],
    });

    return {
      staked: result[0],
      rewards: result[1],
      lockEndTime: result[2],
    };
  }

  // Governance methods
  async createProposal(
    targets: Address[],
    values: bigint[],
    calldatas: `0x${string}`[],
    description: string
  ): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.GOVERNANCE,
      abi: GOVERNANCE_ABI,
      functionName: 'propose',
      args: [targets, values, calldatas, description],
    });
  }

  async castVote(proposalId: bigint, support: 0 | 1 | 2): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.GOVERNANCE,
      abi: GOVERNANCE_ABI,
      functionName: 'castVote',
      args: [proposalId, support],
    });
  }

  async castVoteWithReason(
    proposalId: bigint,
    support: 0 | 1 | 2,
    reason: string
  ): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.GOVERNANCE,
      abi: GOVERNANCE_ABI,
      functionName: 'castVoteWithReason',
      args: [proposalId, support, reason],
    });
  }

  async executeProposal(proposalId: bigint): Promise<Hash> {
    return this.writeContract({
      address: CONTRACTS.GOVERNANCE,
      abi: GOVERNANCE_ABI,
      functionName: 'execute',
      args: [proposalId],
    });
  }

  async getProposal(proposalId: bigint): Promise<{
    id: bigint;
    proposer: Address;
    startTime: bigint;
    endTime: bigint;
    forVotes: bigint;
    againstVotes: bigint;
    abstainVotes: bigint;
    canceled: boolean;
    executed: boolean;
  }> {
    const result = await this.publicClient.readContract({
      address: CONTRACTS.GOVERNANCE,
      abi: GOVERNANCE_ABI,
      functionName: 'getProposal',
      args: [proposalId],
    });

    return {
      id: result[0],
      proposer: result[1],
      startTime: result[2],
      endTime: result[3],
      forVotes: result[4],
      againstVotes: result[5],
      abstainVotes: result[6],
      canceled: result[7],
      executed: result[8],
    };
  }

  async getProposalCount(): Promise<bigint> {
    return this.publicClient.readContract({
      address: CONTRACTS.GOVERNANCE,
      abi: GOVERNANCE_ABI,
      functionName: 'proposalCount',
    });
  }

  // Reputation NFT methods
  async getReputation(account: Address): Promise<bigint> {
    return this.publicClient.readContract({
      address: CONTRACTS.REPUTATION_NFT,
      abi: REPUTATION_NFT_ABI,
      functionName: 'getReputation',
      args: [account],
    });
  }

  async getReputationBalance(account: Address, tokenId: bigint): Promise<bigint> {
    return this.publicClient.readContract({
      address: CONTRACTS.REPUTATION_NFT,
      abi: REPUTATION_NFT_ABI,
      functionName: 'balanceOf',
      args: [account, tokenId],
    });
  }

  // Utility methods
  formatTokenAmount(amount: bigint, decimals: number = 18): string {
    return formatEther(amount);
  }

  parseTokenAmount(amount: string): bigint {
    return parseEther(amount);
  }

  // Transaction monitoring
  async waitForTransaction(hash: Hash) {
    return this.publicClient.waitForTransactionReceipt({ hash });
  }

  // Event listening
  watchContractEvent(params: any) {
    return this.publicClient.watchContractEvent(params);
  }

  // Multicall for batch operations
  async multicall(calls: any[]) {
    return this.publicClient.multicall({
      contracts: calls,
    });
  }
}

// Factory function to create contract service
export const createContractService = (walletClient?: WalletClient): ContractService => {
  return new ContractService(walletClient);
};

// Export default instance
export const contractService = new ContractService();

// Error handling utilities
export class ContractError extends Error {
  constructor(
    message: string,
    public code?: string,
    public data?: any
  ) {
    super(message);
    this.name = 'ContractError';
  }
}

export const handleContractError = (error: any): ContractError => {
  if (error.code === 'ACTION_REJECTED') {
    return new ContractError('Transaction was rejected by user', 'USER_REJECTED');
  }

  if (error.code === 'INSUFFICIENT_FUNDS') {
    return new ContractError('Insufficient funds for transaction', 'INSUFFICIENT_FUNDS');
  }

  if (error.message?.includes('execution reverted')) {
    const reason = error.message.match(/execution reverted: (.+)/)?.[1];
    return new ContractError(
      reason || 'Transaction reverted',
      'EXECUTION_REVERTED',
      { reason }
    );
  }

  return new ContractError(
    error.message || 'Unknown contract error',
    'UNKNOWN_ERROR',
    error
  );
};

// Constants for common operations
export const GAS_LIMITS = {
  APPROVE: 50000n,
  TRANSFER: 65000n,
  STAKE: 200000n,
  UNSTAKE: 150000n,
  VOTE: 100000n,
  PROPOSE: 300000n,
  EXECUTE: 500000n,
} as const;

export const TRANSACTION_TYPES = {
  APPROVE: 'approve',
  TRANSFER: 'transfer',
  STAKE: 'stake',
  UNSTAKE: 'unstake',
  CLAIM_REWARDS: 'claim_rewards',
  DELEGATE: 'delegate',
  VOTE: 'vote',
  PROPOSE: 'propose',
  EXECUTE: 'execute',
} as const;

export type TransactionType = typeof TRANSACTION_TYPES[keyof typeof TRANSACTION_TYPES];